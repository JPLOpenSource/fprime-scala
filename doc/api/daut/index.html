<!DOCTYPE html ><html><head><meta http-equiv="X-UA-Compatible" content="IE=edge"/><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" name="viewport"/><title></title><meta content="" name="description"/><meta content="" name="keywords"/><meta http-equiv="content-type" content="text/html; charset=UTF-8"/><link href="../lib/index.css" media="screen" type="text/css" rel="stylesheet"/><link href="../lib/template.css" media="screen" type="text/css" rel="stylesheet"/><link href="../lib/diagrams.css" media="screen" type="text/css" rel="stylesheet" id="diagrams-css"/><script type="text/javascript" src="../lib/jquery.js"></script><script type="text/javascript" src="../lib/index.js"></script><script type="text/javascript" src="../index.js"></script><script type="text/javascript" src="../lib/scheduler.js"></script><script type="text/javascript" src="../lib/template.js"></script><script type="text/javascript" src="../lib/tools.tooltip.js"></script><script type="text/javascript">/* this variable can be used by the JS to determine the path to the root document */
var toRoot = '../';</script></head><body><div id="search"><span id="doc-title"><span id="doc-version"></span></span> <span class="close-results"><span class="left">&lt;</span> Back</span><div id="textfilter"><span class="input"><input autocapitalize="none" placeholder="Search" id="index-input" type="text" accesskey="/"/><i class="clear material-icons"></i><i id="search-icon" class="material-icons"></i></span></div></div><div id="search-results"><div id="search-progress"><div id="progress-fill"></div></div><div id="results-content"><div id="entity-results"></div><div id="member-results"></div></div></div><div id="content-scroll-container" style="-webkit-overflow-scrolling: touch;"><div id="content-container" style="-webkit-overflow-scrolling: touch;"><div id="subpackage-spacer"><div id="packages"><h1>Packages</h1><ul><li class="indented0 " name="_root_.root" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="_root_"></a><a id="root:_root_"></a> <span class="permalink"><a href="index.html#_root_" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="../index.html" title=""><span class="name">root</span></a></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="../index.html" name="_root_" id="_root_" class="extype">root</a></dd></dl></div></li><li class="indented1 current" name="_root_.daut" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="daut"></a><a id="daut:daut"></a> <span class="permalink"><a href="index.html#daut" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><span class="name">daut</span></span><p class="shortcomment cmt">Daut (Data automata) is an internal Scala DSL for writing event stream monitors.</p><div class="fullcomment"><div class="comment cmt"><p>Daut (Data automata) is an internal Scala DSL for writing event stream monitors. It
supports flavors of state machines, temporal logic, and rule-based programming, all in one
unified formalism. The underlying concept is that at any point during monitoring there is an
active set of states, the _state soup_. States can be added and removed from this soup.
Each state in the soup either monitors the incoming event stream, or is used by other states to record
data (as in rule-based programming).</p><p>The specification language specifically supports:</p><ul><li>Automata, represented by states, parameterized with data (thereby the name Daut: Data automata).</li><li>Temporal operators which generate states, resulting in more succinct specifications.</li><li>Rule-based programming in that one can test for the presence of states and one can add states.</li><li>General purpose programming in Scala when the other specification features fall short.</li></ul><p>The DSL is a simplification of the TraceContract (<a href="https://github.com/havelund/tracecontract" target="_blank">https://github.com/havelund/tracecontract</a>) internal Scala DSL by an order of magnitude less code.</p><p>The general idea is to create a monitor as a class sub-classing the <code>Monitor</code> class,
create an instance of it, and then feed it with events with the <code>verify(event: Event)</code> method,
one by one, and in the case of a finite sequence of observations, finally calling the
<code>end()</code> method on it. If <code>end()</code> is called, it will be determined whether
there are any outstanding obligations that have not been satisfied (expected events that did not occur).</p><p>This can schematically be illustrated as follows:</p><pre><span class="kw">class</span> MyMonitor <span class="kw">extends</span> Monitor[SomeType] {
...
}

<span class="kw">object</span> Main {
  <span class="kw">def</span> main(args: <span class="std">Array</span>[<span class="std">String</span>]) {
    <span class="kw">val</span> m = <span class="kw">new</span> MyMonitor()
    m.verify(event1)
    m.verify(event2)
    ...
    m.verify(eventN)
    m.end()
  }
}</pre></div><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="../index.html" name="_root_" id="_root_" class="extype">root</a></dd></dl></div></li><li class="current-entities indented1"><span class="separator"></span> <a href="Monitor.html" title="Any monitor must sub-class this class." class="class"></a><a href="Monitor.html" title="Any monitor must sub-class this class.">Monitor</a></li><li class="current-entities indented1"><span class="separator"></span> <a href="MonitorError.html" title="If the STOP_ON_ERROR flag is set to true, a MonitorError exception is thrown if a monitor's specification is violated by the observed event stream." class="class"></a><a href="MonitorError.html" title="If the STOP_ON_ERROR flag is set to true, a MonitorError exception is thrown if a monitor's specification is violated by the observed event stream.">MonitorError</a></li></ul></div></div><div id="content"><body class="package value"><div id="definition"><div class="big-circle package">p</div><h1>daut<span class="permalink"><a href="../daut/index.html" title="Permalink"><i class="material-icons"></i></a></span></h1></div><h4 id="signature" class="signature"><span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><span class="name">daut</span></span></h4><div id="comment" class="fullcommenttop"><div class="comment cmt"><p>Daut (Data automata) is an internal Scala DSL for writing event stream monitors. It
supports flavors of state machines, temporal logic, and rule-based programming, all in one
unified formalism. The underlying concept is that at any point during monitoring there is an
active set of states, the _state soup_. States can be added and removed from this soup.
Each state in the soup either monitors the incoming event stream, or is used by other states to record
data (as in rule-based programming).</p><p>The specification language specifically supports:</p><ul><li>Automata, represented by states, parameterized with data (thereby the name Daut: Data automata).</li><li>Temporal operators which generate states, resulting in more succinct specifications.</li><li>Rule-based programming in that one can test for the presence of states and one can add states.</li><li>General purpose programming in Scala when the other specification features fall short.</li></ul><p>The DSL is a simplification of the TraceContract (<a href="https://github.com/havelund/tracecontract" target="_blank">https://github.com/havelund/tracecontract</a>) internal Scala DSL by an order of magnitude less code.</p><p>The general idea is to create a monitor as a class sub-classing the <code>Monitor</code> class,
create an instance of it, and then feed it with events with the <code>verify(event: Event)</code> method,
one by one, and in the case of a finite sequence of observations, finally calling the
<code>end()</code> method on it. If <code>end()</code> is called, it will be determined whether
there are any outstanding obligations that have not been satisfied (expected events that did not occur).</p><p>This can schematically be illustrated as follows:</p><pre><span class="kw">class</span> MyMonitor <span class="kw">extends</span> Monitor[SomeType] {
...
}

<span class="kw">object</span> Main {
  <span class="kw">def</span> main(args: <span class="std">Array</span>[<span class="std">String</span>]) {
    <span class="kw">val</span> m = <span class="kw">new</span> MyMonitor()
    m.verify(event1)
    m.verify(event2)
    ...
    m.verify(eventN)
    m.end()
  }
}</pre></div><div class="toggleContainer"><div class="toggle block"><span>Linear Supertypes</span><div class="superTypes hiddenContent"><span name="scala.AnyRef" class="extype">AnyRef</span>, <span name="scala.Any" class="extype">Any</span></div></div></div></div><div id="template"><div id="allMembers"><div id="types" class="types members"><h3>Type Members</h3><ol><li class="indented0 " name="daut.Monitor" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="Monitor[E]extendsAnyRef"></a><a id="Monitor[E]:Monitor[E]"></a> <span class="permalink"><a href="../daut/index.html#Monitor[E]extendsAnyRef" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">class</span></span> <span class="symbol"><a href="Monitor.html" title="Any monitor must sub-class this class."><span class="name">Monitor</span></a><span class="tparams">[<span name="E">E</span>]</span><span class="result"> extends <span name="scala.AnyRef" class="extype">AnyRef</span></span></span><p class="shortcomment cmt">Any monitor must sub-class this class.</p><div class="fullcomment"><div class="comment cmt"><p>Any monitor must sub-class this class. It provides all the DSL constructs for writing
a monitor.
</p></div><dl class="paramcmts block"><dt class="tparam">E</dt><dd class="cmt"><p>the type of events submitted to the monitor.</p></dd></dl></div></li><li class="indented0 " name="daut.MonitorError" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="MonitorErrorextendsRuntimeExceptionwithProductwithSerializable"></a><a id="MonitorError:MonitorError"></a> <span class="permalink"><a href="../daut/index.html#MonitorErrorextendsRuntimeExceptionwithProductwithSerializable" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">case class</span></span> <span class="symbol"><a href="MonitorError.html" title="If the STOP_ON_ERROR flag is set to true, a MonitorError exception is thrown if a monitor's specification is violated by the observed event stream."><span class="name">MonitorError</span></a><span class="params">()</span><span class="result"> extends <span name="scala.RuntimeException" class="extype">RuntimeException</span> with <span name="scala.Product" class="extype">Product</span> with <span name="scala.Serializable" class="extype">Serializable</span></span></span><p class="shortcomment cmt">If the <code>STOP_ON_ERROR</code> flag is set to true, a <code>MonitorError</code> exception is thrown
if a monitor's specification is violated by the observed event stream.</p></li></ol></div></div><div id="inheritedMembers"><div name="scala.AnyRef" class="parent"><h3>Inherited from <span name="scala.AnyRef" class="extype">AnyRef</span></h3></div><div name="scala.Any" class="parent"><h3>Inherited from <span name="scala.Any" class="extype">Any</span></h3></div></div><div id="groupedMembers"><div name="Ungrouped" class="group"><h3>Ungrouped</h3></div></div></div><div id="tooltip"></div><div id="footer"></div></body></div></div></div></body></html>
