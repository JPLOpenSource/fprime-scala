<!DOCTYPE html ><html><head><meta http-equiv="X-UA-Compatible" content="IE=edge"/><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" name="viewport"/><title></title><meta content="" name="description"/><meta content="" name="keywords"/><meta http-equiv="content-type" content="text/html; charset=UTF-8"/><link href="lib/index.css" media="screen" type="text/css" rel="stylesheet"/><link href="lib/template.css" media="screen" type="text/css" rel="stylesheet"/><link href="lib/diagrams.css" media="screen" type="text/css" rel="stylesheet" id="diagrams-css"/><script type="text/javascript" src="lib/jquery.js"></script><script type="text/javascript" src="lib/index.js"></script><script type="text/javascript" src="index.js"></script><script type="text/javascript" src="lib/scheduler.js"></script><script type="text/javascript" src="lib/template.js"></script><script type="text/javascript" src="lib/tools.tooltip.js"></script><script type="text/javascript">/* this variable can be used by the JS to determine the path to the root document */
var toRoot = '';</script></head><body><div id="search"><span id="doc-title"><span id="doc-version"></span></span> <span class="close-results"><span class="left">&lt;</span> Back</span><div id="textfilter"><span class="input"><input autocapitalize="none" placeholder="Search" id="index-input" type="text" accesskey="/"/><i class="clear material-icons"></i><i id="search-icon" class="material-icons"></i></span></div></div><div id="search-results"><div id="search-progress"><div id="progress-fill"></div></div><div id="results-content"><div id="entity-results"></div><div id="member-results"></div></div></div><div id="content-scroll-container" style="-webkit-overflow-scrolling: touch;"><div id="content-container" style="-webkit-overflow-scrolling: touch;"><div id="subpackage-spacer"><div id="packages"><h1>Packages</h1><ul><li class="indented0 current" name="_root_.root" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="_root_"></a><a id="root:_root_"></a> <span class="permalink"><a href="index.html#_root_" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><span class="name">root</span></span></li><li class="indented1 " name="_root_.daut" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="daut"></a><a id="daut:daut"></a> <span class="permalink"><a href="index.html#daut" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="daut/index.html" title="Daut (Data automata) is an internal Scala DSL for writing event stream monitors."><span class="name">daut</span></a></span><p class="shortcomment cmt">Daut (Data automata) is an internal Scala DSL for writing event stream monitors.</p><div class="fullcomment"><div class="comment cmt"><p>Daut (Data automata) is an internal Scala DSL for writing event stream monitors. It
supports flavors of state machines, temporal logic, and rule-based programming, all in one
unified formalism. The underlying concept is that at any point during monitoring there is an
active set of states, the _state soup_. States can be added and removed from this soup.
Each state in the soup either monitors the incoming event stream, or is used by other states to record
data (as in rule-based programming).</p><p>The specification language specifically supports:</p><ul><li>Automata, represented by states, parameterized with data (thereby the name Daut: Data automata).</li><li>Temporal operators which generate states, resulting in more succinct specifications.</li><li>Rule-based programming in that one can test for the presence of states and one can add states.</li><li>General purpose programming in Scala when the other specification features fall short.</li></ul><p>The DSL is a simplification of the TraceContract (<a href="https://github.com/havelund/tracecontract" target="_blank">https://github.com/havelund/tracecontract</a>) internal Scala DSL by an order of magnitude less code.</p><p>The general idea is to create a monitor as a class sub-classing the <code>Monitor</code> class,
create an instance of it, and then feed it with events with the <code>verify(event: Event)</code> method,
one by one, and in the case of a finite sequence of observations, finally calling the
<code>end()</code> method on it. If <code>end()</code> is called, it will be determined whether
there are any outstanding obligations that have not been satisfied (expected events that did not occur).</p><p>This can schematically be illustrated as follows:</p><pre><span class="kw">class</span> MyMonitor <span class="kw">extends</span> Monitor[SomeType] {
...
}

<span class="kw">object</span> Main {
  <span class="kw">def</span> main(args: <span class="std">Array</span>[<span class="std">String</span>]) {
    <span class="kw">val</span> m = <span class="kw">new</span> MyMonitor()
    m.verify(event1)
    m.verify(event2)
    ...
    m.verify(eventN)
    m.end()
  }
}</pre></div></div></li><li class="indented1 " name="_root_.fprime" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="fprime"></a><a id="fprime:fprime"></a> <span class="permalink"><a href="index.html#fprime" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="fprime/index.html" title="Internal DSL for F', supporting components, ports, commanding, parameters, and telelemtry."><span class="name">fprime</span></a></span><p class="shortcomment cmt">Internal DSL for F', supporting components, ports, commanding, parameters, and telelemtry.</p><div class="fullcomment"><div class="comment cmt"><p>Internal DSL for F', supporting components, ports, commanding, parameters, and telelemtry.
F' is a framework (library, internal DSL) for creating a system of parallel executing
components. Components can be active or passive. An active component contains an internal
thread, while a passive component is like a traditional class. A component's interface is
defined as a set of input ports and a set of output ports. A configuration of components
is defined by linking output ports to input ports.</p><p>Ports can be synchronous or asynchronous. "Sending a message" over a synchronous port
corresponds to calling a method, with an immediate return of a result value. In contrast,
sending a message over an asynchronous port corresponds to message passing as in the actor
model: the message ends up in the receiving components input queue for later processing by
the component's thread. This is a non-blocking operation seen from the sender's point of view.
A passive components cannot have asynchronous input ports.</p><p>The F' framework also supports sending comands to components, receiveing telemetry from
components, and setting parameters in components.</p><p>The thread inside an active component repeatedly reads its input queue and processes the next
input value sent to one of its input ports. All input ports are connected to the same single
input queue.
</p></div></div></li><li class="indented1 " name="_root_.hsm" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="hsm"></a><a id="hsm:hsm"></a> <span class="permalink"><a href="index.html#hsm" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="hsm/index.html" title="Internal DSL for Hierarchical State Machines (HSMs)."><span class="name">hsm</span></a></span><p class="shortcomment cmt">Internal DSL for Hierarchical State Machines (HSMs).</p><div class="fullcomment"><div class="comment cmt"><p>Internal DSL for Hierarchical State Machines (HSMs). HSMs are extended state machines
with the addition of super states, as well as enter and exit statements associated with
states.
</p></div></div></li><li class="indented1 " name="_root_.rules" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="rules"></a><a id="rules:rules"></a> <span class="permalink"><a href="index.html#rules" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="rules/index.html" title="Rules is an internal Scala DSL for writing rule-based tests."><span class="name">rules</span></a></span><p class="shortcomment cmt">Rules is an internal Scala DSL for writing rule-based tests.</p><div class="fullcomment"><div class="comment cmt"><p>Rules is an internal Scala DSL for writing rule-based tests. The DSL, however, can be seen as a stand-alone
DSL for writing rule-based programs in the style of guarded commands. A rule program is a set of rules.
A rule consists of a condition, a pre-condition, an action, and an optional predicate, the post-condition,
to be verified (if present) after the action has been executed. A rule can e.g be declared as follows:</p><pre>rule(<span class="lit">"r3"</span>) { x &gt; <span class="num">0</span> } -&gt; { x -= <span class="num">1</span> } post { x &lt; <span class="num">100</span> }</pre><p>which reads: if <code>x &gt; 0</code> then subtract <code>1</code> from <code>x</code> and verify that <code>x &lt; 100</code>.
If the post-condition fails, an error will be recorded. The rule has the name <code>r3</code>.</p><p>Note that references to rules can be used in defining a rule execution strategy,
so sometimes it is useful to assign these references to variables, as in:</p><pre><span class="kw">val</span> r3 = rule(<span class="lit">"r3"</span>) { x &gt; <span class="num">0</span> } -&gt; { x -= <span class="num">1</span> } post { x &lt; <span class="num">100</span> }</pre><p>To illustrate an example, consider Euclid's algorithm for computing the greatest
common divisor of two numbers <code>A</code> and <code>B</code>, as presented in
<a href="https://en.wikipedia.org/wiki/Guarded_Command_Language" target="_blank">Guarded Command Language</a>:</p><pre>a, b := A, B;
<span class="kw">do</span>
    a &lt; b → b := b - a
  | b &lt; a → a := a - b
od</pre><p>This algorithm can be encoded in Rules as follows.</p><pre><span class="kw">class</span> Euclid(A: <span class="std">Int</span>, B: <span class="std">Int</span>) <span class="kw">extends</span> Rules {
  <span class="kw">var</span> a : <span class="std">Int</span> = A
  <span class="kw">var</span> b : <span class="std">Int</span> = B

  rule (<span class="lit">"r1"</span>) { a &lt; b} -&gt; {b = b - a}
  rule (<span class="lit">"r2"</span>) { b &lt; a} -&gt; {a = a - b}

  <span class="kw">override</span> <span class="kw">def</span> after() {println(s<span class="lit">"a = $a, b = $b"</span>)}
  strategy(Random)
}</pre><p>The class <code>Euclid</code> (parameterized with the numbers <code>A</code> and <code>B</code>) subclasses the class
<code>Rules</code>, which defines the rule DSL. Two variables are declared: <code>a</code> and <code>b</code>, and two rules
are declared.</p><p>In addition the function <code>after</code> is overridden. It is automatically called after each rule execution,
and in this case will print the values of the variables <code>a</code> and <code>b</code>.</p><p>Finally we have to indicate according to which strategy the rules are executed. In this case
we choose: random execution until no rules are enabled (pre-conditions evaluate to true).</p><p>Let's now try to apply our rule program. This is done in the following main program:</p><pre><span class="kw">object</span> Main {
 <span class="kw">def</span> main(args: <span class="std">Array</span>[<span class="std">String</span>]): <span class="std">Unit</span> = {
   <span class="kw">val</span> rules = <span class="kw">new</span> Euclid(<span class="num">212</span>,<span class="num">34</span>)
   rules.fire()
 }
}</pre></div></div></li></ul></div></div><div id="content"><body class="package value"><div id="definition"><div class="big-circle package">p</div><h1>root package <span class="permalink"><a href="index.html" title="Permalink"><i class="material-icons"></i></a></span></h1></div><h4 id="signature" class="signature"><span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><span class="name">root</span></span></h4><div id="comment" class="fullcommenttop"></div><div id="template"><div id="allMembers"><div id="packages" class="package members"><h3>Package Members</h3><ol><li class="indented0 " name="_root_.daut" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="daut"></a><a id="daut:daut"></a> <span class="permalink"><a href="index.html#daut" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="daut/index.html" title="Daut (Data automata) is an internal Scala DSL for writing event stream monitors."><span class="name">daut</span></a></span><p class="shortcomment cmt">Daut (Data automata) is an internal Scala DSL for writing event stream monitors.</p><div class="fullcomment"><div class="comment cmt"><p>Daut (Data automata) is an internal Scala DSL for writing event stream monitors. It
supports flavors of state machines, temporal logic, and rule-based programming, all in one
unified formalism. The underlying concept is that at any point during monitoring there is an
active set of states, the _state soup_. States can be added and removed from this soup.
Each state in the soup either monitors the incoming event stream, or is used by other states to record
data (as in rule-based programming).</p><p>The specification language specifically supports:</p><ul><li>Automata, represented by states, parameterized with data (thereby the name Daut: Data automata).</li><li>Temporal operators which generate states, resulting in more succinct specifications.</li><li>Rule-based programming in that one can test for the presence of states and one can add states.</li><li>General purpose programming in Scala when the other specification features fall short.</li></ul><p>The DSL is a simplification of the TraceContract (<a href="https://github.com/havelund/tracecontract" target="_blank">https://github.com/havelund/tracecontract</a>) internal Scala DSL by an order of magnitude less code.</p><p>The general idea is to create a monitor as a class sub-classing the <code>Monitor</code> class,
create an instance of it, and then feed it with events with the <code>verify(event: Event)</code> method,
one by one, and in the case of a finite sequence of observations, finally calling the
<code>end()</code> method on it. If <code>end()</code> is called, it will be determined whether
there are any outstanding obligations that have not been satisfied (expected events that did not occur).</p><p>This can schematically be illustrated as follows:</p><pre><span class="kw">class</span> MyMonitor <span class="kw">extends</span> Monitor[SomeType] {
...
}

<span class="kw">object</span> Main {
  <span class="kw">def</span> main(args: <span class="std">Array</span>[<span class="std">String</span>]) {
    <span class="kw">val</span> m = <span class="kw">new</span> MyMonitor()
    m.verify(event1)
    m.verify(event2)
    ...
    m.verify(eventN)
    m.end()
  }
}</pre></div></div></li><li class="indented0 " name="_root_.fprime" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="fprime"></a><a id="fprime:fprime"></a> <span class="permalink"><a href="index.html#fprime" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="fprime/index.html" title="Internal DSL for F', supporting components, ports, commanding, parameters, and telelemtry."><span class="name">fprime</span></a></span><p class="shortcomment cmt">Internal DSL for F', supporting components, ports, commanding, parameters, and telelemtry.</p><div class="fullcomment"><div class="comment cmt"><p>Internal DSL for F', supporting components, ports, commanding, parameters, and telelemtry.
F' is a framework (library, internal DSL) for creating a system of parallel executing
components. Components can be active or passive. An active component contains an internal
thread, while a passive component is like a traditional class. A component's interface is
defined as a set of input ports and a set of output ports. A configuration of components
is defined by linking output ports to input ports.</p><p>Ports can be synchronous or asynchronous. "Sending a message" over a synchronous port
corresponds to calling a method, with an immediate return of a result value. In contrast,
sending a message over an asynchronous port corresponds to message passing as in the actor
model: the message ends up in the receiving components input queue for later processing by
the component's thread. This is a non-blocking operation seen from the sender's point of view.
A passive components cannot have asynchronous input ports.</p><p>The F' framework also supports sending comands to components, receiveing telemetry from
components, and setting parameters in components.</p><p>The thread inside an active component repeatedly reads its input queue and processes the next
input value sent to one of its input ports. All input ports are connected to the same single
input queue.
</p></div></div></li><li class="indented0 " name="_root_.hsm" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="hsm"></a><a id="hsm:hsm"></a> <span class="permalink"><a href="index.html#hsm" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="hsm/index.html" title="Internal DSL for Hierarchical State Machines (HSMs)."><span class="name">hsm</span></a></span><p class="shortcomment cmt">Internal DSL for Hierarchical State Machines (HSMs).</p><div class="fullcomment"><div class="comment cmt"><p>Internal DSL for Hierarchical State Machines (HSMs). HSMs are extended state machines
with the addition of super states, as well as enter and exit statements associated with
states.
</p></div></div></li><li class="indented0 " name="_root_.rules" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="rules"></a><a id="rules:rules"></a> <span class="permalink"><a href="index.html#rules" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="rules/index.html" title="Rules is an internal Scala DSL for writing rule-based tests."><span class="name">rules</span></a></span><p class="shortcomment cmt">Rules is an internal Scala DSL for writing rule-based tests.</p><div class="fullcomment"><div class="comment cmt"><p>Rules is an internal Scala DSL for writing rule-based tests. The DSL, however, can be seen as a stand-alone
DSL for writing rule-based programs in the style of guarded commands. A rule program is a set of rules.
A rule consists of a condition, a pre-condition, an action, and an optional predicate, the post-condition,
to be verified (if present) after the action has been executed. A rule can e.g be declared as follows:</p><pre>rule(<span class="lit">"r3"</span>) { x &gt; <span class="num">0</span> } -&gt; { x -= <span class="num">1</span> } post { x &lt; <span class="num">100</span> }</pre><p>which reads: if <code>x &gt; 0</code> then subtract <code>1</code> from <code>x</code> and verify that <code>x &lt; 100</code>.
If the post-condition fails, an error will be recorded. The rule has the name <code>r3</code>.</p><p>Note that references to rules can be used in defining a rule execution strategy,
so sometimes it is useful to assign these references to variables, as in:</p><pre><span class="kw">val</span> r3 = rule(<span class="lit">"r3"</span>) { x &gt; <span class="num">0</span> } -&gt; { x -= <span class="num">1</span> } post { x &lt; <span class="num">100</span> }</pre><p>To illustrate an example, consider Euclid's algorithm for computing the greatest
common divisor of two numbers <code>A</code> and <code>B</code>, as presented in
<a href="https://en.wikipedia.org/wiki/Guarded_Command_Language" target="_blank">Guarded Command Language</a>:</p><pre>a, b := A, B;
<span class="kw">do</span>
    a &lt; b → b := b - a
  | b &lt; a → a := a - b
od</pre><p>This algorithm can be encoded in Rules as follows.</p><pre><span class="kw">class</span> Euclid(A: <span class="std">Int</span>, B: <span class="std">Int</span>) <span class="kw">extends</span> Rules {
  <span class="kw">var</span> a : <span class="std">Int</span> = A
  <span class="kw">var</span> b : <span class="std">Int</span> = B

  rule (<span class="lit">"r1"</span>) { a &lt; b} -&gt; {b = b - a}
  rule (<span class="lit">"r2"</span>) { b &lt; a} -&gt; {a = a - b}

  <span class="kw">override</span> <span class="kw">def</span> after() {println(s<span class="lit">"a = $a, b = $b"</span>)}
  strategy(Random)
}</pre><p>The class <code>Euclid</code> (parameterized with the numbers <code>A</code> and <code>B</code>) subclasses the class
<code>Rules</code>, which defines the rule DSL. Two variables are declared: <code>a</code> and <code>b</code>, and two rules
are declared.</p><p>In addition the function <code>after</code> is overridden. It is automatically called after each rule execution,
and in this case will print the values of the variables <code>a</code> and <code>b</code>.</p><p>Finally we have to indicate according to which strategy the rules are executed. In this case
we choose: random execution until no rules are enabled (pre-conditions evaluate to true).</p><p>Let's now try to apply our rule program. This is done in the following main program:</p><pre><span class="kw">object</span> Main {
 <span class="kw">def</span> main(args: <span class="std">Array</span>[<span class="std">String</span>]): <span class="std">Unit</span> = {
   <span class="kw">val</span> rules = <span class="kw">new</span> Euclid(<span class="num">212</span>,<span class="num">34</span>)
   rules.fire()
 }
}</pre></div></div></li></ol></div></div><div id="inheritedMembers"></div><div id="groupedMembers"><div name="Ungrouped" class="group"><h3>Ungrouped</h3></div></div></div><div id="tooltip"></div><div id="footer"></div></body></div></div></div></body></html>
